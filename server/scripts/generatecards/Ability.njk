{# Formats any type of ability#}
{%- macro formatAbility(ability, refs) -%}
{%- if (ability.name == 'bold') -%}
this.{{ability.trigger}}({{boldAbility(ability, refs)}});
{%- elif (ability.name == 'persistentEffect') -%}
    {%- if ability.target.mode == "upgradedCreature"-%}
this.whileAttached({{persistentEffect(ability, refs | upgradeRefs)}});
    {%- else -%}
this.persistentEffect({{persistentEffect(ability, refs)}});
    {%- endif -%}
{%- elif ability.name == 'reaction' -%}
this.reaction({
    {{formatReaction(ability, refs) | indent(4)}}
});
{%- elif ability.name == 'keywords' -%}
//Keywords: {% for k in ability.keywords -%}
{{k.name}}{{" " + k.count if k.count != null}}{{", " if not loop.last}}
    {%- endfor %}
{%- else -%}
/*{{ ability | dump(2) }}*/
{%- endif -%}
{%- endmacro -%}

{# Bold abilities - these have simple triggers and often have targets. #}
{%- macro boldAbility(ability, refs) -%}
{
{%- for extraTrigger in ability.extraTriggers %}
    {{extraTrigger | lower}}: true,
{%- endfor %}
    {{formatEffects(ability.effect | sortEffects, refs) | indent(4)}}
}
{%- endmacro -%}

{# Persistent effects - WIP #}
{%- macro persistentEffect(ability, refs) -%}
{
{%- if ability.effects[0].name.includes("entersPlay") %}
    location: 'any',
{%- endif -%}
{%- if ability.target != null and (ability.target.controller == 'any' or 
ability.target.controller == null and ability.target.mode == 'all') %}
    targetController: 'any',
{%- elif ability.target != null and ability.target.controller == 'opponent' %}
    targetController: 'opponent',
{%- endif -%}
{%- set c = cardConditionInternal(ability.target, refs, checkType=true) -%}
{%- if c.length > 0 %}
    match: (card{{", context" if c.includes("context") }}) => {{c}},
{%- endif %}
    effect: {{formatEffectArray(ability.effects, refs) | indent(4) }}
}
{%- endmacro -%}

{# Sorts out effects that may be targetted or untargeted, sequential or interdependent. 

 The rule regarding resolving one sentence at a time, except for damage and replacement effects etc. is not implemented yet - and many existing cards don't follow it anyway. In particular, this doesn't generate any unconditional "thens" using alwaysTriggers #}
{%- macro formatEffects(effects, refs) -%}
{%- set j = joiner(",\n") -%}
{# Targetted effects #}
{%- if effects.optional -%}
{{j()}}optional: true
{%- endif -%}
{%- if effects.targets.length > 1 -%}
{{j()}}targets: {
{%- for target in effects.targets %}
    {{- formatCondition(target, refs) -}}
    target{{loop.index}}: {
        {{formatTarget(target, refs) | indent(8) -}}
        gameAction: {{formatSingleEffect(target, refs) | indent(8)}}
    }{{"," if not loop.last }}
{%- endfor %}
}
{%- elif effects.targets.length == 1 -%}
{{j()}}
    {%- if effects.targets[0].condition != null -%}
{{- formatCondition(effects.targets[0], refs) -}}
    {%- endif -%}
target: {
    {{formatTarget(effects.targets[0], refs) | indent(4) -}}
    gameAction: {{formatSingleEffect(effects.targets[0], refs) | indent(4)}}
}
{%- endif -%}
{# Untargetted effects #}
{%- if effects.default.length > 0 -%}
{{- formatCondition(effects.default[0], refs) -}}{# Should really be splitting a group if any have conditions #}
{{- j()}}gameAction: {{formatEffectArray(effects.default, refs)}}
{%- endif -%}
{# Dependent effects #}
{%- if effects.then != null-%}
{{ j()}}then: {% call provideParameters(refs.thenContext) %}{
    {%- if effects.then.alwaysTriggers %}
    alwaysTriggers: true,
    {%- endif %}
    {{formatEffects(effects.then, refs | then | itIs(refs.thenContext + '.target')) | indent(4) }}
}
{%- endcall %}
{%- endif -%}
{# Stuff we can't format yet #}
{%- for unknownEffect in effects.unknown %}
/*Unsupported combinations: {{unknownEffect | dump(2) }}*/
{%- endfor -%}
{%- endmacro -%}

{%- macro formatEffectArray(effects, refs) -%}
{%- if effects.length > 1 -%}
[
    {%- for e in effects %}
    {{ formatSingleEffect(e, refs) | indent(4) }}{{"," if not loop.last }}
    {%- endfor %}
]
{%- elif effects.length == 1 -%}
{{ formatSingleEffect(effects[0], refs) }}
{%- endif %}
{%- endmacro -%}

{# Targetting options setup #}
{%- macro formatTarget(effect, refs) -%}
{%- if effect.target.mode != "exactly" -%}
mode: '{{effect.target.mode}}',
{% endif -%}
{%- if effect.target.count != 1 -%}
numCards: '{{effect.target.count}}',
{% endif -%}
{%- if effect.target.type != null -%}
cardType: '{{effect.target.type}}',
{% endif -%}
{%- if effect.target.controller != null -%}
controller: '{{effect.target.controller}}',
{% endif -%}
{%- if effect.target.location != null -%}
location: '{{effect.target.location}}',
{% endif -%}
{%- set c = cardConditionInternal(effect.target, refs, effect) -%}
{%- if c.length > 0 -%}
cardCondition: (card{{", context" if c.includes("context") }}) => {{ c }},
{% endif -%}
{%- endmacro -%}

{# Individual effect implementations - mostly just calls the matching function, but
there are some exceptions. #}
{%- macro formatSingleEffect(effect, refs) -%}
    {%- if ['gainAmber','stealAmber','gainChains','draw'].includes(effect.name) -%}
ability.actions.{{effect.name}}({{ formatParams(effect, refs, defaultPlayerTarget='self') }})
    {%- elif ['loseAmber', 'discardAtRandom'].includes(effect.name) -%}
ability.actions.{{effect.name}}({{ formatParams(effect, refs, defaultPlayerTarget='opponent') }})
    {%- elif effect.name == 'gainAbility' -%}
        {%- if effect.ability.name == 'bold' -%}
ability.effects.gainAbility('{{effect.ability.trigger}}', {{ boldAbility(effect.ability, refs) }})
        {%- endif -%}
    {%- elif effect.name == 'gainKeywords' -%}
ability.effects.addKeyword({ 
    {%- for keyword in effect.keywords %}
    {{keyword.name}}: {{keyword.count|default(1, true)}}{{"," if not loop.last }}
    {%- endfor %}
})
    {%- elif effect.name == 'readyAndUse' -%}
ability.actions.sequential([
    ability.actions.ready(),
    ability.actions.use()
])
    {%- elif effect.name == 'readyAndFight' -%}
ability.actions.sequential([
    ability.actions.ready(),
    ability.actions.fight()
])
    {%- elif ['forRemainderOfTurn', 'lastingEffect'].includes(effect.name) -%}
        {%- if effect.durationEffect.name == "reaction" or effect.durationEffect.target == null -%}
ability.actions.{{effect.name}}({{formatParams(effect, refs, allowContext=false)}})
        {%- else -%}
ability.actions.cardLastingEffect({{formatParams(effect.durationEffect, refs)}})
        {%- endif -%}
    {%- elif ['entersPlayReady', 'entersPlayStunned'].includes(effect.name) -%}
ability.effects.{{effect.name}}()
    {%- elif ['modifyPower', 'modifyArmor', 'modifyKeyCost'].includes(effect.name) -%}
ability.effects.{{effect.name}}({{effect.amount}})
    {%- elif effect.name == 'unknown' -%}
/*{{effect | dump(2) }}*/
    {%- else -%}
ability.actions.{{effect.name}}({{formatParams(effect, refs)}})
    {%- endif -%}
{%- endmacro -%}

{# Parameters #}
{%- macro formatParams(ability, refs, defaultPlayerTarget=null, allowContext=true) -%}
{%- set params = formatParamsInternal(ability, refs, defaultPlayerTarget) -%}
{%- if params.includes("context") and allowContext -%}
(context) => ({
    {{ params | indent(4) }}
})
{%- elif params.includes("\n") -%}{#- This type of check only works at the lowest level.-#}
{
    {{ params | indent(4) }}
}
{%- elif params.length > 0 -%}
{ {{ params }} }
{%- endif -%}
{%- endmacro -%}

{%- macro whenTriggers(trigger, refs) -%}
{%- if trigger.trigger == "reap" -%}
onReap: {{eventCondition(trigger, refs | check('event.card'))}}
{%- elif trigger.trigger == "play" -%}
onCardPlayed: {{eventCondition(trigger, refs | check('event.card'))}}
{%- elif trigger.trigger == "fight" -%}
onFight: {{eventCondition(trigger, refs | check('event.attacker'))}}
{%- elif trigger.trigger == "destroyed" -%}
onCardDestroyed: {{eventCondition(trigger, refs | check('event.clone'))}}
{%- else -%}
{{ability.durationEffect | dump(2)}}
{%- endif -%}
{%- endmacro-%}

{%- macro formatParamsInternal(ability, refs, defaultPlayerTarget=null) -%}
{%- set j = joiner(',\n') -%}
{%- if ability.target != null and ability.target.mode == "all" -%}
{{j()}}target: context.game.{{ability.target.type}}sInPlay{{cardFilter(ability.target, refs)}}
{%- endif -%}
{%- if ability.target == "$this" -%}
{{j()}}target: {{refs.this}}
{%- endif -%}
{%- if ability.target.mode == "trigger" -%}
{{j()}}target: {{refs.it}}
{%- endif -%}
{%- if ability.durationEffect != null -%}
    {%- if ability.durationEffect.name == "reaction" -%}
{{formatReaction(ability.durationEffect, refs)}}
    {%- else -%}
{{ability.durationEffect | dump(2)}}
    {%- endif -%}
{%- endif -%}
{%- if ability.amount != null -%}
{{j()}}amount: {{ability.amount}}
{%- endif -%}
{%- if ability.location != null -%}
{{j()}}location: '{{ability.location}}'
{%- endif -%}
{%- if ability.fully == true -%}
{{j()}}fully: true
{%- endif -%}
{%- if ability.all == true -%}
{{j()}}all: true
{%- endif -%}
{%- set targetPlayer = ability.targetPlayer if ability.targetPlayer else 'self' -%}
{%- if defaultPlayerTarget != null and targetPlayer !== defaultPlayerTarget -%}
{{j()}}target: {{formatPlayer(targetPlayer, refs)}}
{%- endif -%}
{%- if ability.player != null -%}
{{j()}}player: {{formatPlayer(ability.player, refs)}}
{%- endif -%}
{%- if ability.effects != null -%}
{{j()}}effect: {{formatEffectArray(ability.effects, refs) }} /*{{refs | dump}}*/
{%- endif -%}
{%- endmacro -%}

{% macro formatPlayer(targetPlayer, refs) %}
{%- if targetPlayer === 'self' -%}
context.player
{%- elif targetPlayer === 'opponent' -%}
context.player.opponent
{%- elif targetPlayer === 'owner' -%}
{{refs.it}}.owner
{%- elif targetPlayer === 'ownerOpponent' -%}
{{refs.it}}.owner.opponent
{%- elif targetPlayer === 'controller' -%}
{{refs.it}}.controller
{%- elif targetPlayer === 'controllerOpponent' -%}
{{refs.it}}.controller.opponent
{%- else -%}
/* {{targetPlayer | dump}} */
{%- endif -%}
{% endmacro %}

{# card condition checks #}
{# Card condition requires context if something checks it #}
{# Card filter already has context #}
{%- macro cardFilter(target, refs) -%}
{%- set c = cardConditionInternal(target, refs, null, true) -%}
{%- if c.length > 0 -%}
.filter(
    (card) => {{c}}
) 
{%- endif -%}
{%- endmacro -%}

{%- macro cardConditionInternal(target, refs, effect=null, checkController = false, checkType = false) -%}
{% set j = joiner(' && ') -%}
{%- if effect != null and effect.name == 'use' -%}
{{j()}}{{refs.check}}.exhausted === false{# Is this required, or inbuilt anyway? #}
{%- endif -%}
{%- if target.controller != null and checkController -%}
{{j()}}{{controllerCondition(target, refs)}}
{%- endif -%}
{%- if target.eventPlayer != null -%}
{{j()}}event.player {{ '===' if target.eventPlayer === 'self' else '!==' }} context.player
{%- endif -%}
{%- if target.type != null and checkType -%}
{{j()}}{{refs.check}}.type === '{{target.type}}'
{%- endif -%}
{%- for c in target.conditions -%}
{{j()}}{{singleCondition(c, refs)}}
{%- endfor -%}
{%- endmacro -%}

{# Individual conditions: #}
{%- macro singleCondition(condition, refs) -%}
    {%- if condition.name == "not" -%}
!{{singleCondition(condition.condition, refs)}}
    {%- elif condition.name == "trait" -%}
{{refs.check}}.hasTrait('{{condition.trait}}')
    {%- elif condition.name == "house" -%}
{{refs.check}}.hasHouse('{{condition.house}}')
    {%- elif condition.name == "flank" -%}
{{refs.check}}.isOnFlank()
    {%- elif condition.name == "hasAmber" -%}
{{refs.check}}.hasToken('amber')
    {%- elif condition.name == "damaged" -%}
{{refs.check}}.hasToken('damage')
    {%- elif condition.name == "neighboring" -%}
context.source.neighbors.includes({{refs.check}})
    {%- elif condition.name == "other" -%}
{{refs.check}} !== context.source
    {%- else -%}
/*{{ effect | dump(2)}}*/
    {%- endif -%}
{%- endmacro -%}

{%- macro controllerCondition(target, refs) -%}
{{refs.check}}.controller {{'===' if target.controller === 'self' else '!==' }} context.player
{%- endmacro -%}

{%- macro formatCondition(effect)-%}
{%- if effect.condition == "destroysTarget" -%}
condition: (context) => 
    context.preThenEvent.destroyEvent && context.preThenEvent.destroyEvent.resolved,
{% elif effect.condition != null -%}
condition: /* {{effect.condition | dump(2)}} */
{% endif -%}
{%- endmacro -%}

{%- macro eventCondition(trigger, refs) -%}
{%- set c = cardConditionInternal(trigger.card, refs, null, true, true) -%}
{%- if trigger.condition == "during your turn" -%}
{%- set c = c.concat(' && context.player === this.game.activePlayer') -%}{#TODO Add a proper condition handling system#}
{%- endif -%}
({{"event" if c.includes("event") }}{{", context" if c.includes("context") }}) => {{ c }},
{%- endmacro -%}

{%- macro formatReaction(reaction, refs) -%}
when: {
    {{whenTriggers(reaction.trigger, refs)}}
},
{% if reaction.trigger.trigger == "fight" -%}
{{formatEffects([reaction.effect] | sortEffects, refs | itIs('context.event.attacker'))}}
{%- elif reaction.trigger.trigger == "destroyed" -%}
{{formatEffects([reaction.effect] | sortEffects, refs | itIs('context.event.clone'))}}
{%- else -%}
{{formatEffects([reaction.effect] | sortEffects, refs | itIs('context.event.card'))}}
{%- endif-%}
{%- endmacro -%}

{%- macro provideParameters(parameter) -%}
{% if caller().includes(parameter) -%}
({{parameter}}) => ({{caller()}})
{%- else -%}
{{caller()}}
{%- endif -%}
{%- endmacro -%}
